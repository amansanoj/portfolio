---
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
---

<html lang="en">
	<head>
		<BaseHead title="404 – Page Not Found" description="This page doesn't exist." />
		<style>
			main {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				min-height: 60vh;
				text-align: center;
				padding: 2em 1rem 3em;
			}

			/* ── Hero ───────────────────────────── */
			.code {
				font-size: 6rem;
				font-weight: 700;
				line-height: 1;
				color: var(--accent);
				margin: 0;
			}
			.message {
				font-size: 1.1rem;
				color: rgb(var(--gray));
				margin: 0.4em 0 1em;
			}
			.home-link {
				display: inline-block;
				padding: 0.5em 1.4em;
				background: var(--accent);
				color: #fff;
				text-decoration: none;
				border-radius: 6px;
				font-size: 0.95rem;
				font-weight: 600;
				transition: background 0.15s;
				margin-bottom: 2.4em;
			}
			.home-link:hover { background: var(--accent-dark); }

			/* ── Arcade section ─────────────────── */
			.arcade-section {
				width: 100%;
				max-width: 980px;
			}

			/* ── Cards ──────────────────────────── */
			.arcade-grid {
				display: flex;
				flex-direction: column;
				gap: 1em;
				align-items: center;
				width: 100%;
			}
			.arcade-card {
				background: rgb(var(--bg));
				border-radius: 10px;
				border: 1.5px solid rgb(var(--border));
				overflow: hidden;
				box-shadow: var(--box-shadow);
				width: 100%;
				max-width: 600px;
			}
			.card-runner {}
			.card-snake  {}

			.card-marquee {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 0.45em 1em;
				border-bottom: 1px solid rgb(var(--border));
			}
			.card-title {
				font-family: monospace;
				font-size: clamp(0.75rem, 3vw, 0.82rem);
				font-weight: 700;
				letter-spacing: 0.12em;
				color: rgb(var(--gray));
				text-transform: uppercase;
			}
			.card-controls {
				font-family: monospace;
				font-size: clamp(0.65rem, 2.5vw, 0.72rem);
				color: rgb(var(--gray));
				letter-spacing: 0.03em;
				opacity: 0.7;
			}

			#runner-canvas,
			#snake-canvas,
			#breakout-canvas {
				display: block;
				width: 100%;
				cursor: pointer;
				touch-action: none;
				-webkit-user-select: none;
				user-select: none;
			}

			/* overlay start button */
			.canvas-wrap {
				position: relative;
			}
			.game-focus-btn {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				border: none;
				background: rgba(var(--bg), 0.88);
				cursor: pointer;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				gap: 0.35em;
				font-family: monospace;
				padding: 0;
			}
			.game-focus-btn .btn-title {
				font-size: clamp(0.85rem, 4vw, 1rem);
				font-weight: 700;
				letter-spacing: 0.08em;
				color: rgb(var(--gray-dark));
			}
			.game-focus-btn .btn-sub {
				font-size: clamp(0.7rem, 3vw, 0.78rem);
				color: rgb(var(--gray));
				letter-spacing: 0.04em;
			}
			.game-focus-btn:focus-visible {
				outline: 2px solid var(--accent);
				outline-offset: -3px;
			}

			/* show keyboard hints on desktop, touch hints on mobile */
			.ctrl-kbd  { display: inline; }
			.ctrl-touch { display: none; }
			@media (pointer: coarse) {
				.ctrl-kbd  { display: none; }
				.ctrl-touch { display: inline; }
			}
			.card-hud {
				display: flex;
				justify-content: space-between;
				padding: 0.45em 1em;
				border-top: 1px solid rgb(var(--border));
				font-family: monospace;
				font-size: clamp(0.76rem, 3vw, 0.84rem);
				color: rgb(var(--gray));
				letter-spacing: 0.05em;
			}

			/* ── Mobile overrides ─────────────────────── */
			@media (max-width: 480px) {
				.arcade-section { padding: 0 0.25rem; }
				.arcade-card { border-radius: 8px; }
				.card-marquee { padding: 0.5em 0.75em; }
				.card-hud { padding: 0.5em 0.75em; }
			}

			/* ── God mode toast ───────────────────────────── */
			#god-toast {
				position: fixed;
				bottom: 1.5em;
				left: 50%;
				transform: translateX(-50%) translateY(4em);
				background: var(--accent);
				color: #fff;
				font-family: monospace;
				font-size: 0.78rem;
				font-weight: 700;
				letter-spacing: 0.1em;
				padding: 0.5em 1.2em;
				border-radius: 6px;
				box-shadow: 0 4px 16px rgba(0,0,0,0.18);
				transition: transform 0.3s ease, opacity 0.3s ease;
				opacity: 0;
				pointer-events: none;
				z-index: 9999;
			}
			#god-toast.show {
				transform: translateX(-50%) translateY(0);
				opacity: 1;
			}
		</style>
	</head>
	<body data-page="404">
		<Header />
		<main id="main-content" tabindex="-1">
			<p class="code">404</p>
			<p class="message">oops, you found my secret arcade.</p>
			<a class="home-link" href="/">Go home</a>

			<div class="arcade-section">

				<div class="arcade-grid">
					<div class="arcade-card card-runner">
						<div class="card-marquee">
							<span class="card-title">DASH</span>
						</div>
						<div class="canvas-wrap">
						<canvas id="runner-canvas"></canvas>
						<button class="game-focus-btn" id="runner-focus-btn" aria-label="Play DASH">
							<span class="btn-title">PRESS TO PLAY</span>
							<span class="btn-sub ctrl-kbd">SPACE — jump</span>
							<span class="btn-sub ctrl-touch">TAP — jump</span>
						</button>
					</div>
						<div class="card-hud">
							<span id="runner-score">SCORE 00000</span>
							<span id="runner-best">BEST 00000</span>
						</div>
					</div>

					<div class="arcade-card card-snake">
						<div class="card-marquee">
							<span class="card-title">SNAKE</span>
						</div>
						<div class="canvas-wrap">
						<canvas id="snake-canvas"></canvas>
						<button class="game-focus-btn" id="snake-focus-btn" aria-label="Play SNAKE">
							<span class="btn-title">PRESS TO PLAY</span>
							<span class="btn-sub ctrl-kbd">ARROWS / WASD — move</span>
							<span class="btn-sub ctrl-touch">SWIPE — move</span>
						</button>
					</div>
						<div class="card-hud">
							<span id="snake-score">SCORE 000</span>
							<span id="snake-best">BEST 000</span>
						</div>
					</div>

				<div class="arcade-card card-breakout">
					<div class="card-marquee">
						<span class="card-title">BREAKOUT</span>
					</div>
					<div class="canvas-wrap">
					<canvas id="breakout-canvas"></canvas>
					<button class="game-focus-btn" id="breakout-focus-btn" aria-label="Play BREAKOUT">
						<span class="btn-title">PRESS TO PLAY</span>
						<span class="btn-sub ctrl-kbd">MOUSE / ARROWS — paddle</span>
						<span class="btn-sub ctrl-touch">DRAG — paddle</span>
					</button>
				</div>
					<div class="card-hud">
						<span id="breakout-score">SCORE 00000</span>
						<span id="breakout-best">BEST 00000</span>
					</div>
				</div>

				</div>
			</div>
		</main>
		<Footer />

		<div id="god-toast">★ GOD MODE</div>

		<script>
		let _gameFocus: string | null = null;
		let _godMode = false;

		// ── Konami code ────────────────────────────────────────
		const KONAMI = ['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','KeyB','KeyA'];
		let _konamiIdx = 0;
		document.addEventListener('keydown', e => {
			if (e.code === KONAMI[_konamiIdx]) {
				_konamiIdx++;
				if (_konamiIdx === KONAMI.length) {
					_konamiIdx = 0;
					_godMode = !_godMode;
					const toast = document.getElementById('god-toast')!;
					toast.textContent = _godMode ? '★ GOD MODE ON' : '★ GOD MODE OFF';
					toast.classList.add('show');
					setTimeout(() => toast.classList.remove('show'), 2200);
				}
			} else {
				_konamiIdx = e.code === KONAMI[0] ? 1 : 0;
			}
		});
		// ════════════════════════════════════════════════════════
		//  GAME 1 — DASH (endless runner)
		// ════════════════════════════════════════════════════════
		(() => {
			const canvas = document.getElementById('runner-canvas') as HTMLCanvasElement;
			const ctx = canvas.getContext('2d')!;
			const elScore = document.getElementById('runner-score')!;
			const elBest  = document.getElementById('runner-best')!;

			const LOGICAL_W = 600;
			const CANVAS_H = 160;
			const GROUND_Y = CANVAS_H - 28;
			const P_W = 22, P_H = 28;
			const GRAVITY = 0.55, JUMP_V = -10.5;
			const INIT_SPEED = 4.2, SPEED_INC = 0.0008;
			let dpr = 1, scale = 1;

			function resize() {
				const rect = canvas.parentElement!.getBoundingClientRect();
				const displayW = Math.min(rect.width, LOGICAL_W);
				scale = displayW / LOGICAL_W;
				const displayH = CANVAS_H * scale;
				dpr = window.devicePixelRatio || 1;
				canvas.width  = displayW * dpr;
				canvas.height = displayH * dpr;
				canvas.style.height = displayH + 'px';
				ctx.setTransform(1,0,0,1,0,0);
				ctx.scale(dpr, dpr);
			}
			window.addEventListener('resize', resize);
			resize();

			const C = (() => {
				const s = getComputedStyle(document.documentElement);
				return {
					bg:     `rgb(${s.getPropertyValue('--bg').trim()})`,
					ground: `rgba(${s.getPropertyValue('--gray').trim()},0.2)`,
					player: '#2383e2',
					eye:    '#93c5fd',
					obs:    `rgb(${s.getPropertyValue('--gray-dark').trim()})`,
					text:   `rgb(${s.getPropertyValue('--gray-dark').trim()})`,
					sub:    `rgb(${s.getPropertyValue('--gray').trim()})`,
					over:   `rgba(${s.getPropertyValue('--bg').trim()},0.8)`,
				};
			})();

			type Obs = { x: number; w: number; h: number };
			let px: number, py: number, vy: number, onGround: boolean;
			let obstacles: Obs[], score: number, speed: number;
			let highScore = Number(localStorage.getItem('dash_best') ?? 0);
			let state: 'idle' | 'running' | 'dead', frame: number, lastObs: number, groundOffset: number;

			function reset() {
				px = 60; py = GROUND_Y - P_H; vy = 0; onGround = true;
				obstacles = []; score = 0; speed = INIT_SPEED; lastObs = 0; groundOffset = 0;
			}

			function jump() {
				if (state === 'running' && onGround) { vy = JUMP_V; onGround = false; }
			}

			const btn = document.getElementById('runner-focus-btn') as HTMLButtonElement;
			const btnTitle = btn.querySelector('.btn-title') as HTMLElement;
			function showRunnerBtn(title: string) { btnTitle.textContent = title; btn.style.display = ''; btn.focus(); }
			const activateRunner = () => {
				_gameFocus = 'runner';
				btn.style.display = 'none';
				if (state === 'idle') { state = 'running'; reset(); vy = JUMP_V; onGround = false; }
				else { state = 'running'; reset(); }
			};
			btn.addEventListener('click', activateRunner);
			btn.addEventListener('touchend', e => { e.preventDefault(); activateRunner(); });

			document.addEventListener('keydown', e => {
				if (e.code === 'Space' && _gameFocus === 'runner') { e.preventDefault(); jump(); }
			});
			canvas.addEventListener('pointerdown', e => { if (_gameFocus !== 'runner') return; e.preventDefault(); jump(); });

			function maybeSpawn() {
				const minGap = Math.max(180, 320 - score * 0.3);
				if (frame - lastObs < minGap / speed) return;
				const h = 20 + Math.random() * 22, w = 14 + Math.random() * 10;
				obstacles.push({ x: LOGICAL_W + 10, w, h });
				lastObs = frame;
			}

			function collides(o: Obs) {
				return px < o.x + o.w && px + P_W > o.x && py < GROUND_Y && py + P_H > GROUND_Y - o.h;
			}

			function rr(x: number, y: number, w: number, h: number, r: number, fill: string) {
				ctx.fillStyle = fill;
				ctx.beginPath();
				ctx.roundRect(x*scale, y*scale, w*scale, h*scale, r*scale);
				ctx.fill();
			}

			let _lastTs = 0;
			function tick(ts: number = 0) {
				const dt = _lastTs ? Math.min(ts - _lastTs, 50) : 16.667;
				const dt60 = dt / 16.667; // 1.0 at 60 fps, 0.5 at 120 fps, etc.
				_lastTs = ts;
				frame += dt60;
				const W = LOGICAL_W, H = CANVAS_H;
				ctx.fillStyle = C.bg;
				ctx.fillRect(0, 0, W*scale, H*scale);

				// Ground
				if (state === 'running') groundOffset = (groundOffset + speed * dt60) % 30;
				ctx.strokeStyle = C.ground; ctx.lineWidth = 1.5*scale;
				ctx.beginPath(); ctx.moveTo(0, GROUND_Y*scale); ctx.lineTo(W*scale, GROUND_Y*scale); ctx.stroke();
				ctx.lineWidth = 1*scale;
				for (let x = -groundOffset; x < W; x += 30) {
					ctx.beginPath(); ctx.moveTo(x*scale, (GROUND_Y+6)*scale); ctx.lineTo((x+14)*scale, (GROUND_Y+6)*scale); ctx.stroke();
				}

				if (state === 'running') {
					speed += SPEED_INC * dt60; score += dt60;
					vy += GRAVITY * dt60; py += vy * dt60;
					if (py >= GROUND_Y - P_H) { py = GROUND_Y - P_H; vy = 0; onGround = true; }
					maybeSpawn();
					for (const o of obstacles) o.x -= speed * dt60;
					obstacles = obstacles.filter(o => o.x + o.w > -10);
					for (const o of obstacles) {
						if (collides(o)) {
						if (_godMode) continue;
						const s = Math.floor(score);
						state = 'dead'; if (s > highScore) { highScore = s; localStorage.setItem('dash_best', String(highScore)); } showRunnerBtn('PLAY AGAIN');
					}
					}
				}

				// Obstacles (drawn before player so sprite is always on top)
				for (const o of obstacles) rr(o.x, GROUND_Y-o.h, o.w, o.h, 3, C.obs);

				// Player
				const squish = (state === 'running' && !onGround) ? Math.max(0.8, 1 - Math.abs(vy)*0.025) : 1;
				const drawH = P_H * squish, drawY = py + (P_H - drawH);
				rr(px, drawY, P_W, drawH, 5, C.player);
				ctx.fillStyle = '#fff';
				ctx.beginPath(); ctx.arc((px+P_W-6)*scale, (drawY+8)*scale, 3*scale, 0, Math.PI*2); ctx.fill();
				ctx.fillStyle = C.eye;
				ctx.beginPath(); ctx.arc((px+P_W-5)*scale, (drawY+8)*scale, 1.5*scale, 0, Math.PI*2); ctx.fill();

				// DOM HUD
				const displayScore = Math.floor(score);
				elScore.textContent = `SCORE ${String(displayScore).padStart(5,'0')}`;
				elBest.textContent  = `BEST  ${String(highScore).padStart(5,'0')}`;

				// Overlay
				ctx.textAlign = 'center';
				requestAnimationFrame(tick);
			}

			frame = 0; state = 'idle'; reset();
			requestAnimationFrame(tick);
		})();

		// ════════════════════════════════════════════════════════
		//  GAME 2 — SNAKE
		// ════════════════════════════════════════════════════════
		(() => {
			const canvas = document.getElementById('snake-canvas') as HTMLCanvasElement;
			const ctx = canvas.getContext('2d')!;
			const elScore = document.getElementById('snake-score')!;
			const elBest  = document.getElementById('snake-best')!;

			// Fixed grid dimensions — CELL is computed from container width so the
			// canvas always fills available space and font sizes scale like the runner.
			const S_COLS = 25, S_ROWS = 12;
			let CELL = 24, COLS = S_COLS, ROWS = S_ROWS;
			let W = COLS * CELL, H = ROWS * CELL;
			let snakeScale = 1;

			const C = (() => {
				const s = getComputedStyle(document.documentElement);
				return {
					bg:     `rgb(${s.getPropertyValue('--bg').trim()})`,
					grid:   `rgba(${s.getPropertyValue('--gray').trim()},0.1)`,
					border: `rgb(${s.getPropertyValue('--border').trim()})`,
					player: '#2383e2',
					head:   '#93c5fd',
					food:   '#f97316',
					text:   `rgb(${s.getPropertyValue('--gray-dark').trim()})`,
					sub:    `rgb(${s.getPropertyValue('--gray').trim()})`,
					over:   `rgba(${s.getPropertyValue('--bg').trim()},0.8)`,
				};
			})();

			const OPP = { U:'D', D:'U', L:'R', R:'L' } as const;
			const KEY: Record<string, 'U'|'D'|'L'|'R'> = {
				ArrowUp:'U', KeyW:'U', ArrowDown:'D', KeyS:'D',
				ArrowLeft:'L', KeyA:'L', ArrowRight:'R', KeyD:'R',
			};

			let snake: {x:number,y:number}[], dir: 'U'|'D'|'L'|'R', nextDir: 'U'|'D'|'L'|'R';
			let food: {x:number,y:number};
			let score: number, speed: number;
			let highScore = Number(localStorage.getItem('snake_best') ?? 0);
			let state: 'idle'|'running'|'dead'|'won' = 'idle';
			let tid: ReturnType<typeof setTimeout> | null = null;

			function rand(n: number) { return Math.floor(Math.random() * n); }
			function placeFood() {
				let f: {x:number,y:number};
				do { f = { x: rand(COLS), y: rand(ROWS) }; }
				while (snake.some(s => s.x === f.x && s.y === f.y));
				food = f;
			}
			function reset() {
				const mx = Math.floor(COLS/2), my = Math.floor(ROWS/2);
				snake = [{ x:mx,y:my },{ x:mx-1,y:my },{ x:mx-2,y:my }];
				dir = 'R'; nextDir = 'R'; score = 0; speed = 150;
				placeFood();
			}

			// Init state before first draw
			reset();

			function setCanvasSize() {
				const dpr = window.devicePixelRatio || 1;
				const containerW = canvas.parentElement!.getBoundingClientRect().width;
				COLS = S_COLS; ROWS = S_ROWS;
				CELL = containerW / COLS;
				W = containerW; H = CELL * ROWS;
				snakeScale = containerW / 600;
				canvas.width  = W * dpr;
				canvas.height = H * dpr;
				canvas.style.width  = '100%';
				canvas.style.height = H + 'px';
				ctx.setTransform(1,0,0,1,0,0);
				ctx.scale(dpr, dpr);
			}

			function resize() { setCanvasSize(); draw(); }
			window.addEventListener('resize', resize);
			setCanvasSize(); // size first, then draw below after everything is ready

			function restart(preserveScore = false) {
				const savedScore = score;
				if (tid) { clearTimeout(tid); tid = null; }
				reset();
				if (preserveScore) { score = savedScore; speed = Math.max(65, 150 - score * 4); }
				state = 'running'; schedule();
			}
			function schedule() {
				tid = setTimeout(() => { step(); if (state === 'running') schedule(); }, speed);
			}
			function step() {
				dir = nextDir;
				const h = { ...snake[0] };
				if (dir==='U') h.y--; if (dir==='D') h.y++;
				if (dir==='L') h.x--; if (dir==='R') h.x++;
				if (h.x<0||h.x>=COLS||h.y<0||h.y>=ROWS||snake.some(s=>s.x===h.x&&s.y===h.y)) {
					if (_godMode) {
						h.x = (h.x + COLS) % COLS;
						h.y = (h.y + ROWS) % ROWS;
					} else {
						state = 'dead'; if (score > highScore) { highScore = score; localStorage.setItem('snake_best', String(highScore)); } showSnakeBtn('PLAY AGAIN'); draw(); return;
					}
				}
				snake.unshift(h);
				if (h.x===food.x && h.y===food.y) {
					score++; if (score > highScore) { highScore = score; localStorage.setItem('snake_best', String(highScore)); }
					speed = Math.max(65, 150 - score*4);
					if (snake.length === COLS * ROWS) {
						state = 'won'; if (tid) { clearTimeout(tid); tid = null; } showSnakeBtn('NEXT ROUND'); draw(); return;
					}
					placeFood();
				} else { snake.pop(); }
				draw();
			}

			// Keyboard
			document.addEventListener('keydown', e => {
				const d = KEY[e.code];
				if (!d) return;
					if (_gameFocus !== 'snake') return;
					e.preventDefault();
					if (state !== 'running') return;
				if (d !== OPP[dir]) nextDir = d;
			});
			// Mouse click to start (desktop only — touch uses swipe handler below)
				canvas.addEventListener('pointerdown', e => { if (e.pointerType === 'touch') return; if (_gameFocus !== 'snake') return; if (state !== 'running') restart(state === 'won'); });

				// Touch swipe: tap = start/restart, swipe = change direction
				let tx = 0, ty = 0;
				canvas.addEventListener('touchstart', e => { if (_gameFocus === 'snake') { tx = e.touches[0].clientX; ty = e.touches[0].clientY; } }, { passive:true });

				const snakeBtn = document.getElementById('snake-focus-btn') as HTMLButtonElement;
				const snakeBtnTitle = snakeBtn.querySelector('.btn-title') as HTMLElement;
				function showSnakeBtn(title: string) { snakeBtnTitle.textContent = title; snakeBtn.style.display = ''; snakeBtn.focus(); }
				snakeBtn.addEventListener('click', () => {
					const preserve = state === 'won';
					_gameFocus = 'snake';
					snakeBtn.style.display = 'none';
					restart(preserve);
				});
				snakeBtn.addEventListener('touchend', e => { e.preventDefault(); const preserve = state === 'won'; _gameFocus = 'snake'; snakeBtn.style.display = 'none'; restart(preserve); });
			canvas.addEventListener('touchend', e => {
				if (_gameFocus !== 'snake') return;
				if (state !== 'running') return;
				const dx = e.changedTouches[0].clientX - tx;
				const dy = e.changedTouches[0].clientY - ty;
				if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return;
				const d = (Math.abs(dx) > Math.abs(dy) ? (dx>0?'R':'L') : (dy>0?'D':'U')) as 'U'|'D'|'L'|'R';
				if (d !== OPP[dir]) nextDir = d;
			}, { passive:true });

			function draw() {
				ctx.fillStyle = C.bg; ctx.fillRect(0,0,W,H);

				// Grid
				ctx.strokeStyle = C.grid; ctx.lineWidth = 0.5;
				for (let i=0;i<=COLS;i++){ctx.beginPath();ctx.moveTo(i*CELL,0);ctx.lineTo(i*CELL,H);ctx.stroke();}
				for (let j=0;j<=ROWS;j++){ctx.beginPath();ctx.moveTo(0,j*CELL);ctx.lineTo(W,j*CELL);ctx.stroke();}

				if (state === 'idle') {
					ctx.textAlign = 'center';
					ctx.fillStyle = C.over; ctx.fillRect(0,0,W,H);
					return;
				}

				// Food
				ctx.fillStyle = C.food;
				ctx.beginPath();
				ctx.arc(food.x*CELL+CELL/2, food.y*CELL+CELL/2, CELL/2-1.5, 0, Math.PI*2);
				ctx.fill();

				// Snake — gradient over first 5 segments (head→4 behind), rest stays darkest
				const sn = snake.length;
				for (let i=sn-1;i>=0;i--) {
					const s = snake[i];
					const t = Math.min(i, 4) / 4; // 0 = head, 1 = 4th body segment onwards
					const r = Math.round(147 - 121 * t);
					const g = Math.round(197 -  90 * t);
					const b = Math.round(253 -  62 * t);
					ctx.fillStyle = `rgb(${r},${g},${b})`;
					ctx.beginPath();
					ctx.roundRect(s.x*CELL+1, s.y*CELL+1, CELL-2, CELL-2, i===0?4:2);
					ctx.fill();
				}

				// DOM HUD
				elScore.textContent = `SCORE ${String(score).padStart(5,'0')}`;
				elBest.textContent  = `BEST  ${String(highScore).padStart(5,'0')}`;

				// Game over overlay — handled by button
			}

			draw(); // initial render
		})();

		// ════════════════════════════════════════════════════════
		//  GAME 3 — BREAKOUT
		// ════════════════════════════════════════════════════════
		(() => {
			const canvas = document.getElementById('breakout-canvas') as HTMLCanvasElement;
			const ctx = canvas.getContext('2d')!;
			const elScore = document.getElementById('breakout-score')!;
			const elBest  = document.getElementById('breakout-best')!;

			const LOGICAL_W = 600, LOGICAL_H = 280;
			const PADDLE_W = 80, PADDLE_H = 10;
			const PADDLE_Y = LOGICAL_H - 22;
			const BALL_R = 7;
			const BK_COLS = 10, BK_ROWS = 5;
			const BK_GAP = 4, BK_MARGIN = 4, BK_TOP = 24, BK_H = 14;
			const BK_W = (LOGICAL_W - BK_MARGIN * 2 - BK_GAP * (BK_COLS - 1)) / BK_COLS;
			const ROW_COLORS = ['#93c5fd', '#60a5fa', '#3b82f6', '#2383e2', '#1a6bbf'];
			const INIT_SPEED = 4.5;
			const PADDLE_SPEED = 6;

			let dpr = 1, scale = 1;

			function resize() {
				const rect = canvas.parentElement!.getBoundingClientRect();
				const displayW = Math.min(rect.width, LOGICAL_W);
				scale = displayW / LOGICAL_W;
				const displayH = LOGICAL_H * scale;
				dpr = window.devicePixelRatio || 1;
				canvas.width  = displayW * dpr;
				canvas.height = displayH * dpr;
				canvas.style.height = displayH + 'px';
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.scale(dpr, dpr);
			}
			window.addEventListener('resize', resize);
			resize();

			const C = (() => {
				const s = getComputedStyle(document.documentElement);
				return {
					bg:   `rgb(${s.getPropertyValue('--bg').trim()})`,
					text: `rgb(${s.getPropertyValue('--gray-dark').trim()})`,
					sub:  `rgb(${s.getPropertyValue('--gray').trim()})`,
					over: `rgba(${s.getPropertyValue('--bg').trim()},0.85)`,
				};
			})();

			let highScore = Number(localStorage.getItem('breakout_best') ?? 0);

			type Brick = { x: number; y: number; alive: boolean; color: string };
			let bricks: Brick[];
			let pdx: number;
			let bx: number, by: number, vx: number, vy: number;
			let score: number, spd: number;
			let state: 'idle' | 'running' | 'dead' | 'won' = 'idle';

			function makeBricks() {
				bricks = [];
				for (let r = 0; r < BK_ROWS; r++)
					for (let c = 0; c < BK_COLS; c++)
						bricks.push({ x: BK_MARGIN + c*(BK_W+BK_GAP), y: BK_TOP + r*(BK_H+BK_GAP), alive: true, color: ROW_COLORS[r] });
			}

			function reset() {
				pdx = LOGICAL_W / 2;
				bx = LOGICAL_W / 2; by = PADDLE_Y - BALL_R - 2;
				const a = -Math.PI / 2 + (Math.random() - 0.5) * 0.9;
				spd = INIT_SPEED;
				vx = spd * Math.cos(a); vy = spd * Math.sin(a);
				score = 0;
				makeBricks();
			}
			reset();

			function start(preserveScore = false) {
				const savedScore = score;
				reset();
				if (preserveScore) score = savedScore;
				state = 'running';
			}

			// ── Input ───────────────────────────────────────────
			let keyLeft = false, keyRight = false;

			canvas.addEventListener('mousemove', e => {
				if (state !== 'running') return;
				const rect = canvas.getBoundingClientRect();
				pdx = (e.clientX - rect.left) / scale;
			});
			canvas.addEventListener('touchmove', e => {
				e.preventDefault();
				const rect = canvas.getBoundingClientRect();
				pdx = (e.touches[0].clientX - rect.left) / scale;
			}, { passive: false });

			canvas.addEventListener('pointerdown', e => {
				if (_gameFocus !== 'breakout') return;
				if (e.pointerType === 'touch') return;
				if (state !== 'running') start();
			});
			canvas.addEventListener('touchstart', () => { }, { passive: true });
			canvas.addEventListener('touchend', () => { if (_gameFocus === 'breakout' && state !== 'running') start(); }, { passive: true });

			const breakoutBtn = document.getElementById('breakout-focus-btn') as HTMLButtonElement;
			const breakoutBtnTitle = breakoutBtn.querySelector('.btn-title') as HTMLElement;
			function showBreakoutBtn(title: string) { breakoutBtnTitle.textContent = title; breakoutBtn.style.display = ''; breakoutBtn.focus(); }
			breakoutBtn.addEventListener('click', () => {
				const preserve = state === 'won';
				_gameFocus = 'breakout';
				breakoutBtn.style.display = 'none';
				start(preserve);
			});
			breakoutBtn.addEventListener('touchend', e => { e.preventDefault(); const preserve = state === 'won'; _gameFocus = 'breakout'; breakoutBtn.style.display = 'none'; start(preserve); });

			document.addEventListener('keydown', e => {
				if (_gameFocus !== 'breakout') return;
					if (e.code === 'ArrowLeft'  && state === 'running') { e.preventDefault(); keyLeft  = true; }
					if (e.code === 'ArrowRight' && state === 'running') { e.preventDefault(); keyRight = true; }
			});
			document.addEventListener('keyup', e => {
				if (e.code === 'ArrowLeft')  keyLeft  = false;
				if (e.code === 'ArrowRight') keyRight = false;
			});

			// ── Game loop ────────────────────────────────────────
			let _lastTs = 0;
			function tick(ts: number = 0) {
				const dt = _lastTs ? Math.min(ts - _lastTs, 50) : 16.667;
				const dt60 = dt / 16.667;
				_lastTs = ts;
				const W = LOGICAL_W, H = LOGICAL_H;

				if (state === 'running') {
					if (keyLeft)  pdx -= PADDLE_SPEED * dt60;
					if (keyRight) pdx += PADDLE_SPEED * dt60;
					pdx = Math.max(PADDLE_W/2, Math.min(W - PADDLE_W/2, pdx));

					bx += vx * dt60; by += vy * dt60;

					// Wall bounces
					if (bx - BALL_R < 0)  { bx = BALL_R;     vx =  Math.abs(vx); }
					if (bx + BALL_R > W)  { bx = W - BALL_R; vx = -Math.abs(vx); }
					if (by - BALL_R < 0)  { by = BALL_R;      vy =  Math.abs(vy); }

					// Paddle bounce — spin based on contact point
					const pdL = pdx - PADDLE_W/2, pdR = pdx + PADDLE_W/2;
					if (vy > 0 && by + BALL_R >= PADDLE_Y && by - BALL_R <= PADDLE_Y + PADDLE_H && bx >= pdL && bx <= pdR) {
						const hit = (bx - pdx) / (PADDLE_W/2);
						const angle = hit * (Math.PI / 3);
						const s = Math.hypot(vx, vy);
						vx = s * Math.sin(angle);
						vy = -Math.abs(s * Math.cos(angle));
					}

					// Ball lost
					if (by - BALL_R > H) {
						if (_godMode) {
							by = H - BALL_R; vy = -Math.abs(vy);
						} else {
							state = 'dead';
							if (score > highScore) { highScore = score; localStorage.setItem('breakout_best', String(highScore)); }
							showBreakoutBtn('PLAY AGAIN');
						}
					}

					// Brick collisions
					for (const b of bricks) {
						if (!b.alive) continue;
						if (bx+BALL_R > b.x && bx-BALL_R < b.x+BK_W && by+BALL_R > b.y && by-BALL_R < b.y+BK_H) {
							b.alive = false; score++;
							if (score > highScore) { highScore = score; localStorage.setItem('breakout_best', String(highScore)); }
							const ol = (bx+BALL_R) - b.x, or_ = (b.x+BK_W) - (bx-BALL_R);
							const ot = (by+BALL_R) - b.y, ob  = (b.y+BK_H) - (by-BALL_R);
							if (Math.min(ol,or_) < Math.min(ot,ob)) vx = -vx; else vy = -vy;
							spd = Math.min(INIT_SPEED + score * 0.07, 9);
							const s = Math.hypot(vx, vy);
							vx = vx/s*spd; vy = vy/s*spd;
							break;
						}
					}
					if (bricks.every(b => !b.alive)) { state = 'won'; showBreakoutBtn('NEXT ROUND'); }
				}

				// ── Draw ─────────────────────────────────────────────
				ctx.fillStyle = C.bg; ctx.fillRect(0, 0, W*scale, H*scale);

				for (const b of bricks) {
					if (!b.alive) continue;
					ctx.fillStyle = b.color;
					ctx.beginPath();
					ctx.roundRect(b.x*scale, b.y*scale, BK_W*scale, BK_H*scale, 2*scale);
					ctx.fill();
				}

				ctx.fillStyle = '#2383e2';
				ctx.beginPath();
				ctx.roundRect((pdx-PADDLE_W/2)*scale, PADDLE_Y*scale, PADDLE_W*scale, PADDLE_H*scale, 4*scale);
				ctx.fill();

				ctx.fillStyle = '#2383e2';
				ctx.beginPath();
				ctx.arc(bx*scale, by*scale, BALL_R*scale, 0, Math.PI*2);
				ctx.fill();
				ctx.fillStyle = 'rgba(255,255,255,0.35)';
				ctx.beginPath();
				ctx.arc((bx-2)*scale, (by-2.5)*scale, BALL_R*0.38*scale, 0, Math.PI*2);
				ctx.fill();

				elScore.textContent = `SCORE ${String(score).padStart(5,'0')}`;
				elBest.textContent  = `BEST  ${String(highScore).padStart(5,'0')}`;

				ctx.textAlign = 'center';
				// dead/won states handled by button

				requestAnimationFrame(tick);
			}

			requestAnimationFrame(tick);
		})();
		</script>
	</body>
</html>
